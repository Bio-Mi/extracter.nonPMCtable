def table_to_2d(t):
    rows = t.find_all('tr')
    
    # How many column 
    
    ftrow= [str(link.get('colspan')) for link in t.tbody.tr.find_all('td')]
    for n, i in enumerate(ftrow):
        if i == 'None':
            ftrow[n] = '1'
    col_n = sum([int(i) for i in ftrow])       
    
    # build an empty matrix for all possible cells
    rows = t.find_all('tr')
    table = [[''] * col_n for row in rows]
    
    # fill matrix from row data
    rowspans = {}  # track pending rowspans, column number mapping to count
    for row_idx, row in enumerate(rows):
        span_offset = 0  # how many columns are skipped due to row and colspans 
        for col_idx, cell in enumerate(row.findAll(['td', 'th'])):
            # adjust for preceding row and colspans
            col_idx += span_offset
            while rowspans.get(col_idx, 0):
                span_offset += 1
                col_idx += 1
        
            # fill table data
            if not cell.get('colspan'):
                colspan = 1
            else:
                colspan= int(cell.get('colspan'))

            if not cell.get('rowspan'):
                rowspan = 1
            else:
                rowspan= int(cell.get('rowspan'))
    
            # next column is offset by the colspan
            span_offset += colspan - 1
            value = cell.get_text()
            
            for drow, dcol in product(range(rowspan), range(colspan)):
                try:
                    table[row_idx + drow][col_idx + dcol] = value
                    rowspans[col_idx + dcol] = rowspan
                except IndexError:
                    # rowspan or colspan outside the confines of the table
                    pass

       
        # update rowspan bookkeeping
        rowspans = {c: s - 1 for c, s in rowspans.items() if s > 1}
        
    return table
